# 03-api
Use this to add Company specific API stuff like the configuration of the projects within the Company.

The following structure is generated by `./helperCompany.scala init`:

```bash
03-api/src
         | main/resources
         | main/scala/company/api
         |                     | CompanyApiCreator.scala          
         | test/scala/company/api       
```

## CompanyApiCreator

The Company's base class to generate the API documentation and API Clients for Postman.

Example (generated by `./helperCompany.scala init`):

```scala
import orchescala.api.*

trait CompanyApiCreator extends ApiCreator, ApiDsl, CamundaPostmanApiCreator:

    // override the config if needed
    protected def apiConfig: ApiConfig = CompanyApiCreator.apiConfig

    lazy val companyProjectVersion = BuildInfo.version
    
object CompanyApiCreator:
    lazy val apiConfig = ApiConfig(
      engineConfig = DefaultEngineConfig(),
      companyName = "mycompany"
    )
end CompanyApiCreator
```

## ApiConfig
You can customize the API Configuration.

Here an example:

```scala mdoc
import orchescala.api.ApiConfig
import orchescala.engine.DefaultEngineConfig

lazy val apiConfig: ApiConfig =
  ApiConfig(
    engineConfig = DefaultEngineConfig(),
    companyName = "mycompany"
  )
    .withTenantId("mycompany")
    .withDocBaseUrl(s"http://mycompany.ch/bpmnDocs")
    .withJiraUrls("COM" -> "https://issue.mycompany.ch/browse")
```

### Default ApiConfig
This is the default Configuration:
```scala
// Engine configuration (includes tenant, parallelism, validation, etc.)
engineConfig: EngineConfig,
// your company name like 'mycompany'
companyName: String,
// contact email / phone, if there are questions
contact: Option[Contact] = None,
// REST endpoint (for testing API)
endpoint: String = "http://localhost:8080/engine-rest",
// Base Path of your project (if changed - all doc paths will be adjusted)
basePath: os.Path = os.pwd,
// If you work with JIRA, you can add matchers that will create automatically URLs to JIRA Tasks
jiraUrls: Map[String, String] = Map.empty,
// Configure your project setup
projectsConfig: ProjectsConfig = ProjectsConfig(),
// For generating references to other projects, your Workers/Processes are used in
otherProjectsConfig: ProjectsConfig = ProjectsConfig(),
// Configure your template generation (supports multiple configs for C7 and C8)
modelerTemplateConfigs: Seq[ModelerTemplateConfig] = Seq(
  ModelerTemplateConfig(),
  ModelerTemplateConfig(
    supportedEngine = SupportedEngine.C8,
    templateRelativePath = os.rel / ".camunda" / "element-templates" / "c8"
  )
),
// The URL of your published documentations
// s"http://myCompany/bpmnDocs"
docBaseUrl: Option[String] = None,
// Path, where the Git Projects are cloned - for dependency check.
// the default is for the structure: dev-myCompany/projects/myProject
tempGitDir: os.Path = os.pwd / os.up / os.up /  os.up / "git-temp"
```

### EngineConfig
The `EngineConfig` controls engine behavior and parallelism:

```scala
case class DefaultEngineConfig(
    // define tenant if you have one
    tenantId: Option[String] = None,
    // The key of the process variable that contains an additional value to verify the impersonate User
    impersonateProcessKey: Option[String] = None,
    // Secret key for signing IdentityCorrelation (HMAC-SHA256). Should be set from environment variable.
    identitySigningKey: Option[String] = sys.env.get("ORCHESCALA_IDENTITY_SIGNING_KEY"),
    // Base path for worker apps
    workersBasePath: String = WorkerForwardUtil.localWorkerAppUrl,
    // Validate input variables before starting a process instance
    validateInput: Boolean = true,
    // Parallelism limit for concurrent fiber execution in parallel operations
    // Controls how many workers, simulations, and API operations run concurrently
    parallelism: Int = 4
)
```

You can customize the engine config:

```scala mdoc:reset
import orchescala.api.ApiConfig
import orchescala.engine.DefaultEngineConfig

lazy val customEngineConfig = DefaultEngineConfig(
  tenantId = Some("mycompany"),
  parallelism = 8,  // Increase parallelism for better performance
  validateInput = true
)

lazy val apiConfig: ApiConfig =
  ApiConfig(
    engineConfig = customEngineConfig,
    companyName = "mycompany"
  )
```

## ProjectsConfig
You can configure your projects.

Here an example:

```scala mdoc
import orchescala.api.*

lazy val projectsConfig = ProjectsConfig(
  // Path to your ApiProjectConf - default is os.pwd / PROJECT.conf
  projectConfPath = os.rel / "src" / "main" / "resources" / "myproject.conf",
  // grouped configs per GitRepos - so it is possible to use projects from different Repos
  perGitRepoConfigs = Seq(myCompanyGitRepoConfig)
)

lazy val myCompanyGitRepoConfig = ProjectsPerGitRepoConfig(
  // Base URL for the Git Repos
  // The pattern must be $cloneBaseUrl/$projectName.git
  cloneBaseUrl = "ssh://git@mycompany.com:2222/myrepo",
  // Definition of the projects
  projects = myProjects
)

lazy val myProjects = Seq(`mycompany-services`, `mycompany-finances`, `mycompany-employees`)

lazy val `mycompany-services` = ProjectConfig(
  // Name of the project
  name = "mycompany-services",
  // you can group your projects - for better overview
  group =  services,
  // the color of your project - for better overview and visualization in the BPMN diagrams
  color = "blue"
)

lazy val `mycompany-finances` = ???
lazy val `mycompany-employees` = ???
lazy val services = ProjectGroup(
  name = "services",
  // line color
  color = "purple",
  fill = "#ddd"
)

```

@:callout(info)
All other information is taken automatically from the _ApiProjectConf_.
@:@

## Standard Features:

With the API Creator you get a lot of features out of the box.

### README
If you have a read me in your base path (`config.basePath / "README.md`),
we integrate it automatically in the documentation - as a visible part.

### CHANGELOG
If you have a change log in your base path (`config.basePath / "CHANGELOG.md`),
we integrate it automatically in the documentation - as a collapsed part.

### General Variables
General variables that are supported in any Process- and/or ExternalTask-Worker are documented - in a collapsed part.
By default, the following Variables are supported:

```scala mdoc
enum InputParams:
  // mocking
  case _servicesMocked
  case _mockedWorkers
  case _outputMock
  case _outputServiceMock
  // mapping
  case _manualOutMapping
  case _outputVariables
  case _handledErrors
  case _regexHandledErrors
  // authorization
  case _identityCorrelation
  // ..
end InputParams
```
That expects that your implementation can handle these variables.

@:callout(info)
If you are using our Workers they are supported out of the box!
@:@

If you only want to support some of them, you can override them:

```scala
  override def supportedVariables: Seq[InputParams] = Seq(
    _servicesMocked,
    _outputMock,
    _outputServiceMock,
    _handledErrors,
    _regexHandledErrors,
    _identityCorrelation
  )
```

### Jira Tickets
We replace configured JIRA Ticket pattern with its URL.

Configuration:
```scala
  override protected def apiConfig: ApiConfig =
    super.apiConfig
      .withJiraUrls(JIRA_PROJECT -> JIRA_URL)  
```

- JIRA_PROJECT: The shortcut for the JIRA Project (prefix of jira ticket number).
- JIRA_URL: The base URL to browse JIRA tickets, e.g. `https://issue.mycompany.ch/browse`.

Now in the Change Log all occurrences of the regex `JIRA_PROJECT-(\\d+)` (-> `JIRA_TICKET`)
will be replaced with `[JIRA_TICKET]($url/JIRA_TICKET)`.
In the generated documentation this is a link to the according Jira ticket.

### BPMN diagrams
BPMN- and DMN diagrams are integrated in the documentation.

They are referenced in the OpenApi.html and can be opened directly from there. 
There are 3 ways:

1. As an image in the documentation
2. As a link to download the BPMN-/ DMN-diagram
3. As SVG image to show the diagram in the browser (you can zoom in and out)

@:callout(info)
This is only working if you upload your BPMN- and DMN-diagrams to a Web server (via WebDAV).
@:@


### Project dependencies
To know where your process is used and what processes your process is using, is very helpful.
It works for **BPMN**s and **DMN**s.

Orchescala will clone or update all configured projects:

`ProjectsConfig.perGitRepoConfigs/$project.git` into `ApiConfig.tempGitDir`

for example:

`https://github.com/mycompany/mycompany-myproject.git` -> `../../../git-temp/mycompany-myproject`.

It creates bullet lists grouped by projects:

---
Used in 2 Project(s)

- myProjectA
    - Process: myProcessAA
    - Process: myProcessAC

- myProjectB
    - Process: myProcessBA

Uses 1 Project(s)

- myHelperProject
    - Process: myHelperProcess
    - DMN: myHelperDMN
    - Worker: myWorkerAA
    - DMN: myDMNAA
    - UserTask: myUserTaskAA

---

#### Used Dependency Resolution
For each Process (BPMN):

- Takes the id of the DMN or BPMN.
- Checks all DMNs and BPMNs of all configured projects, if they refer this id.
- Lists these DMNs and BPMNs, grouped by their projects.

#### Uses Dependency Resolution

For each Process (BPMN or DMN):

- Extracts all referred ids of DMNs and BPMNs.
- Lists the DMNs and BPMNs, grouped by their projects - Generic Service Processes are listed by their service name.

@:callout(info)
The BPMNs and DMNs are resolved by their ids. So it is essential that the ids are unique.

This is done by following naming conventions.
You can easily enforce that by using the provided generators, see [Generate Process/-Elements].

@:@
